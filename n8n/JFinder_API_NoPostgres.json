{
  "name": "JFinder API - All Endpoints (No Postgres)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "search",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "search-webhook",
      "name": "Search Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 240],
      "webhookId": "search"
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "listing/:id",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "listing-webhook",
      "name": "Listing Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 440],
      "webhookId": "listing"
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "stats",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "stats-webhook",
      "name": "Stats Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 640],
      "webhookId": "stats"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "roi",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "roi-webhook",
      "name": "ROI Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 840],
      "webhookId": "roi"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "valuation",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "valuation-webhook",
      "name": "Valuation Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 1040],
      "webhookId": "valuation"
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "districts",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "districts-webhook",
      "name": "Districts Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 1240],
      "webhookId": "districts"
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// LOAD DATA FROM VERIFIED JSON FILE\n// This is a shared data loader for all endpoints\n// Data is loaded from: /data/files/vn_rental_3cities_verified.json\n// ====================================================================\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Try multiple paths for the data file\nconst possiblePaths = [\n  '/data/files/vn_rental_3cities_verified.json',\n  '/home/node/.n8n/files/vn_rental_3cities_verified.json',\n  '/files/vn_rental_3cities_verified.json',\n  './data/vn_rental_3cities_verified.json'\n];\n\nlet listings = [];\nlet loadError = null;\n\nfor (const filePath of possiblePaths) {\n  try {\n    if (fs.existsSync(filePath)) {\n      const rawData = fs.readFileSync(filePath, 'utf8');\n      listings = JSON.parse(rawData);\n      console.log(`Loaded ${listings.length} listings from ${filePath}`);\n      break;\n    }\n  } catch (err) {\n    loadError = err.message;\n  }\n}\n\n// If still no data, use inline fallback (should be replaced with actual data mount)\nif (listings.length === 0) {\n  console.warn('Could not load data file, using empty array. Mount data volume properly.');\n}\n\n// Store in workflow static data for reuse\n$getWorkflowStaticData('global').listings = listings;\n$getWorkflowStaticData('global').loadedAt = new Date().toISOString();\n\nreturn { json: { loaded: listings.length, timestamp: new Date().toISOString() } };"
      },
      "id": "load-data",
      "name": "Load Data (Startup)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [60, 60]
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// SEARCH ENDPOINT - Filter listings from JSON data\n// GET /webhook/search?city=&district=&ward=&type=&min_price=&max_price=&limit=&offset=\n// ====================================================================\n\nconst query = $input.first().json.query || {};\n\n// Get listings from static data or reload\nlet listings = $getWorkflowStaticData('global').listings || [];\n\n// If no data cached, try to load\nif (listings.length === 0) {\n  const fs = require('fs');\n  const paths = [\n    '/data/files/vn_rental_3cities_verified.json',\n    '/home/node/.n8n/files/vn_rental_3cities_verified.json'\n  ];\n  for (const p of paths) {\n    try {\n      if (fs.existsSync(p)) {\n        listings = JSON.parse(fs.readFileSync(p, 'utf8'));\n        $getWorkflowStaticData('global').listings = listings;\n        break;\n      }\n    } catch(e) {}\n  }\n}\n\n// Filter function\nfunction normalize(str) {\n  if (!str) return '';\n  return str.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').trim();\n}\n\nfunction matches(listing, field, value) {\n  if (!value) return true;\n  const listingValue = normalize(listing[field] || '');\n  const searchValue = normalize(value);\n  return listingValue.includes(searchValue);\n}\n\n// Apply filters\nlet results = listings.filter(l => {\n  // City/Province filter\n  if (query.city || query.province) {\n    const citySearch = query.city || query.province;\n    if (!matches(l, 'province', citySearch)) return false;\n  }\n  \n  // District filter\n  if (query.district && !matches(l, 'district', query.district)) return false;\n  \n  // Ward filter\n  if (query.ward && !matches(l, 'ward', query.ward)) return false;\n  \n  // Type filter\n  if (query.type && l.type !== query.type) return false;\n  \n  // Segment filter\n  if (query.segment && l.market_segment !== query.segment) return false;\n  \n  // Price filters\n  const price = l.price || l.price_million || 0;\n  const minPrice = parseFloat(query.min_price || query.minPrice) || 0;\n  const maxPrice = parseFloat(query.max_price || query.maxPrice) || Infinity;\n  if (price < minPrice || price > maxPrice) return false;\n  \n  // Area filters\n  const area = l.area || l.area_m2 || 0;\n  const minArea = parseFloat(query.min_area || query.minArea) || 0;\n  const maxArea = parseFloat(query.max_area || query.maxArea) || Infinity;\n  if (area < minArea || area > maxArea) return false;\n  \n  // Geo filter (radius)\n  if (query.lat && query.lon && query.radius_m) {\n    const lat = parseFloat(query.lat);\n    const lon = parseFloat(query.lon);\n    const radius = parseFloat(query.radius_m);\n    const listingLat = l.latitude || l.lat || 0;\n    const listingLon = l.longitude || l.lon || 0;\n    \n    // Haversine distance\n    const R = 6371000; // meters\n    const dLat = (listingLat - lat) * Math.PI / 180;\n    const dLon = (listingLon - lon) * Math.PI / 180;\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n              Math.cos(lat * Math.PI / 180) * Math.cos(listingLat * Math.PI / 180) *\n              Math.sin(dLon/2) * Math.sin(dLon/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    const distance = R * c;\n    \n    if (distance > radius) return false;\n  }\n  \n  return true;\n});\n\n// Sort by posted_at desc\nresults.sort((a, b) => {\n  const dateA = new Date(a.posted_at || 0);\n  const dateB = new Date(b.posted_at || 0);\n  return dateB - dateA;\n});\n\n// Pagination\nconst limit = parseInt(query.limit) || 50;\nconst offset = parseInt(query.offset) || 0;\nconst paginated = results.slice(offset, offset + limit);\n\n// Transform to FE expected format\nconst output = paginated.map(l => ({\n  id: l.id,\n  name: l.name,\n  title: l.name, // alias\n  address: l.address,\n  province: l.province,\n  district: l.district,\n  ward: l.ward,\n  latitude: l.latitude,\n  longitude: l.longitude,\n  lat: l.latitude, // alias\n  lon: l.longitude, // alias\n  type: l.type,\n  market_segment: l.market_segment,\n  area_m2: l.area || l.area_m2,\n  area: l.area || l.area_m2, // alias\n  frontage_m: l.frontage || l.frontage_m,\n  frontage: l.frontage || l.frontage_m, // alias\n  floors: l.floors,\n  price_million: l.price || l.price_million,\n  price: l.price || l.price_million, // alias\n  rent_per_sqm_million: l.rent_per_sqm_million,\n  views: l.views || 0,\n  saved_count: l.savedCount || l.saved_count || 0,\n  savedCount: l.savedCount || l.saved_count || 0, // alias\n  primary_image_url: l.primary_image_url,\n  ai_suggested_price: l.ai_suggested_price,\n  ai_potential_score: l.ai_potential_score,\n  ai_risk_level: l.ai_risk_level,\n  price_label: (() => {\n    if (!l.ai_suggested_price || !l.price) return 'fair';\n    const ratio = (l.price || l.price_million) / l.ai_suggested_price;\n    if (ratio < 0.9) return 'cheap';\n    if (ratio > 1.1) return 'expensive';\n    return 'fair';\n  })(),\n  posted_at: l.posted_at,\n  created_at: l.posted_at,\n  owner: typeof l.owner === 'string' ? JSON.parse(l.owner.replace(/'/g, '\"')) : l.owner,\n  // Geo verification fields\n  geo_status: l.geo_status,\n  geo_method: l.geo_method,\n  admin_match_level: l.admin_match_level\n}));\n\nreturn {\n  json: {\n    success: true,\n    data: output,\n    count: output.length,\n    total: results.length,\n    limit,\n    offset\n  }\n};"
      },
      "id": "search-filter",
      "name": "Search Filter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 240]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" },
              { "name": "Access-Control-Allow-Methods", "value": "GET, POST, OPTIONS" },
              { "name": "Access-Control-Allow-Headers", "value": "Content-Type" }
            ]
          }
        }
      },
      "id": "search-respond",
      "name": "Search Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 240]
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// LISTING DETAIL ENDPOINT\n// GET /webhook/listing/:id\n// ====================================================================\n\nconst params = $input.first().json.params || {};\nconst listingId = params.id;\n\nlet listings = $getWorkflowStaticData('global').listings || [];\n\n// Reload if needed\nif (listings.length === 0) {\n  const fs = require('fs');\n  const paths = [\n    '/data/files/vn_rental_3cities_verified.json',\n    '/home/node/.n8n/files/vn_rental_3cities_verified.json'\n  ];\n  for (const p of paths) {\n    try {\n      if (fs.existsSync(p)) {\n        listings = JSON.parse(fs.readFileSync(p, 'utf8'));\n        $getWorkflowStaticData('global').listings = listings;\n        break;\n      }\n    } catch(e) {}\n  }\n}\n\n// Find listing\nconst listing = listings.find(l => l.id === listingId);\n\nif (!listing) {\n  return {\n    json: {\n      success: false,\n      error: 'Listing not found',\n      data: null\n    }\n  };\n}\n\n// Calculate price label\nlet priceLabel = 'fair';\nconst price = listing.price || listing.price_million || 0;\nif (listing.ai_suggested_price && price) {\n  const ratio = price / listing.ai_suggested_price;\n  if (ratio < 0.9) priceLabel = 'cheap';\n  else if (ratio > 1.1) priceLabel = 'expensive';\n}\n\n// Parse owner if string\nlet owner = listing.owner;\nif (typeof owner === 'string') {\n  try {\n    owner = JSON.parse(owner.replace(/'/g, '\"'));\n  } catch(e) {\n    owner = { name: 'Unknown', phone: '' };\n  }\n}\n\n// Get area stats for context\nconst sameDistrict = listings.filter(l => \n  l.district === listing.district && \n  l.type === listing.type\n);\n\nconst prices = sameDistrict.map(l => l.price || l.price_million || 0).filter(p => p > 0);\nprices.sort((a, b) => a - b);\n\nconst areaStats = {\n  listing_count: sameDistrict.length,\n  median_price: prices.length > 0 ? prices[Math.floor(prices.length / 2)] : 0,\n  p25_price: prices.length > 0 ? prices[Math.floor(prices.length * 0.25)] : 0,\n  p75_price: prices.length > 0 ? prices[Math.floor(prices.length * 0.75)] : 0\n};\n\nreturn {\n  json: {\n    success: true,\n    found: true,\n    data: {\n      id: listing.id,\n      name: listing.name,\n      title: listing.name,\n      address: listing.address,\n      province: listing.province,\n      district: listing.district,\n      ward: listing.ward,\n      latitude: listing.latitude,\n      longitude: listing.longitude,\n      lat: listing.latitude,\n      lon: listing.longitude,\n      type: listing.type,\n      market_segment: listing.market_segment,\n      area_m2: listing.area || listing.area_m2,\n      area: listing.area || listing.area_m2,\n      frontage_m: listing.frontage || listing.frontage_m,\n      frontage: listing.frontage || listing.frontage_m,\n      floors: listing.floors,\n      price_million: price,\n      price: price,\n      rent_per_sqm_million: listing.rent_per_sqm_million,\n      views: listing.views || 0,\n      saved_count: listing.savedCount || listing.saved_count || 0,\n      savedCount: listing.savedCount || listing.saved_count || 0,\n      primary_image_url: listing.primary_image_url,\n      ai_suggested_price: listing.ai_suggested_price,\n      ai_potential_score: listing.ai_potential_score,\n      ai_risk_level: listing.ai_risk_level,\n      price_label: priceLabel,\n      posted_at: listing.posted_at,\n      created_at: listing.posted_at,\n      owner: owner,\n      area_stats: areaStats,\n      geo_status: listing.geo_status,\n      geo_method: listing.geo_method,\n      admin_match_level: listing.admin_match_level\n    }\n  }\n};"
      },
      "id": "listing-detail",
      "name": "Get Listing Detail",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 440]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "listing-respond",
      "name": "Listing Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 440]
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// STATS ENDPOINT - Compute stats from JSON data\n// GET /webhook/stats?level=district|ward&city=\n// ====================================================================\n\nconst query = $input.first().json.query || {};\nconst level = query.level || 'district';\nconst cityFilter = query.city || query.province || '';\n\nlet listings = $getWorkflowStaticData('global').listings || [];\n\n// Reload if needed\nif (listings.length === 0) {\n  const fs = require('fs');\n  const paths = [\n    '/data/files/vn_rental_3cities_verified.json',\n    '/home/node/.n8n/files/vn_rental_3cities_verified.json'\n  ];\n  for (const p of paths) {\n    try {\n      if (fs.existsSync(p)) {\n        listings = JSON.parse(fs.readFileSync(p, 'utf8'));\n        $getWorkflowStaticData('global').listings = listings;\n        break;\n      }\n    } catch(e) {}\n  }\n}\n\nfunction normalize(str) {\n  if (!str) return '';\n  return str.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').trim();\n}\n\n// Filter by city if specified\nlet filtered = listings;\nif (cityFilter) {\n  const cityNorm = normalize(cityFilter);\n  filtered = listings.filter(l => normalize(l.province || '').includes(cityNorm));\n}\n\n// Group by level\nconst groups = {};\n\nfiltered.forEach(l => {\n  let key;\n  if (level === 'ward') {\n    key = `${l.province}|${l.district}|${l.ward}|${l.type}`;\n  } else {\n    key = `${l.province}|${l.district}`;\n  }\n  \n  if (!groups[key]) {\n    groups[key] = {\n      province: l.province,\n      district: l.district,\n      ward: level === 'ward' ? l.ward : undefined,\n      type: level === 'ward' ? l.type : undefined,\n      prices: [],\n      views: [],\n      saved: 0\n    };\n  }\n  \n  const price = l.price || l.price_million || 0;\n  if (price > 0) groups[key].prices.push(price);\n  groups[key].views.push(l.views || 0);\n  groups[key].saved += (l.savedCount || l.saved_count || 0);\n});\n\n// Calculate stats\nconst stats = Object.values(groups).map(g => {\n  const prices = g.prices.sort((a, b) => a - b);\n  const n = prices.length;\n  \n  return {\n    province: g.province,\n    district: g.district,\n    ward: g.ward,\n    type: g.type,\n    listing_count: n,\n    median_price: n > 0 ? prices[Math.floor(n / 2)] : 0,\n    p25_price: n > 0 ? prices[Math.floor(n * 0.25)] : 0,\n    p75_price: n > 0 ? prices[Math.floor(n * 0.75)] : 0,\n    min_price: n > 0 ? prices[0] : 0,\n    max_price: n > 0 ? prices[n - 1] : 0,\n    avg_views: g.views.length > 0 ? Math.round(g.views.reduce((a, b) => a + b, 0) / g.views.length) : 0,\n    total_saved: g.saved\n  };\n}).filter(s => s.listing_count > 0);\n\n// Sort by province, district\nstats.sort((a, b) => {\n  if (a.province !== b.province) return a.province.localeCompare(b.province);\n  if (a.district !== b.district) return a.district.localeCompare(b.district);\n  if (a.ward && b.ward) return a.ward.localeCompare(b.ward);\n  return 0;\n});\n\nreturn {\n  json: {\n    success: true,\n    level,\n    data: stats,\n    count: stats.length\n  }\n};"
      },
      "id": "stats-compute",
      "name": "Compute Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 640]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "stats-respond",
      "name": "Stats Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 640]
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// ROI CALCULATOR ENDPOINT\n// POST /webhook/roi\n// Body: { monthly_rent, product_price, profit_margin, target_daily_customers, operating_cost }\n// ====================================================================\n\nconst body = $input.first().json.body || {};\n\n// Parse inputs with fallbacks for different naming conventions\nconst monthlyRent = parseFloat(body.monthly_rent || body.monthlyRent) || 50;\nconst productPrice = parseFloat(body.product_price || body.productPrice) || 50000;\nconst profitMargin = parseFloat(body.profit_margin || body.profitMargin) || 0.3;\nconst dailyCustomers = parseInt(body.target_daily_customers || body.dailyCustomers) || 100;\nconst operatingCost = parseFloat(body.operating_cost || body.operatingCost) || 10;\n\n// Calculate ROI metrics\nconst monthlyRentVND = monthlyRent * 1000000;\nconst operatingCostVND = operatingCost * 1000000;\nconst profitPerItem = productPrice * profitMargin;\nconst dailyProfit = profitPerItem * dailyCustomers;\nconst monthlyRevenue = dailyProfit * 30;\nconst totalMonthlyCost = monthlyRentVND + operatingCostVND;\nconst monthlyNetProfit = monthlyRevenue - totalMonthlyCost;\nconst breakEvenDays = totalMonthlyCost > 0 ? Math.ceil(totalMonthlyCost / dailyProfit) : 0;\nconst roiPercent = totalMonthlyCost > 0 ? ((monthlyNetProfit / totalMonthlyCost) * 100) : 0;\n\n// Determine viability\nlet viability = 'excellent';\nif (breakEvenDays > 25) viability = 'risky';\nelse if (breakEvenDays > 20) viability = 'moderate';\nelse if (breakEvenDays > 15) viability = 'good';\n\n// Calculate yearly metrics\nconst yearlyRevenue = monthlyRevenue * 12;\nconst yearlyNetProfit = monthlyNetProfit * 12;\nconst yearlyROI = totalMonthlyCost > 0 ? ((yearlyNetProfit / (totalMonthlyCost * 12)) * 100) : 0;\n\nreturn {\n  json: {\n    success: true,\n    inputs: {\n      monthly_rent_million: monthlyRent,\n      product_price_vnd: productPrice,\n      profit_margin: profitMargin,\n      daily_customers: dailyCustomers,\n      operating_cost_million: operatingCost\n    },\n    results: {\n      daily_profit_vnd: Math.round(dailyProfit),\n      monthly_revenue_vnd: Math.round(monthlyRevenue),\n      total_monthly_cost_vnd: Math.round(totalMonthlyCost),\n      monthly_net_profit_vnd: Math.round(monthlyNetProfit),\n      yearly_revenue_vnd: Math.round(yearlyRevenue),\n      yearly_net_profit_vnd: Math.round(yearlyNetProfit),\n      break_even_days: breakEvenDays,\n      roi_percent: Math.round(roiPercent * 10) / 10,\n      yearly_roi_percent: Math.round(yearlyROI * 10) / 10,\n      viability: viability\n    },\n    assumptions: {\n      days_per_month: 30,\n      rent_unit: 'million VND/month',\n      operating_cost_unit: 'million VND/month',\n      product_price_unit: 'VND'\n    }\n  }\n};"
      },
      "id": "roi-calc",
      "name": "Calculate ROI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 840]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "roi-respond",
      "name": "ROI Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 840]
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// VALUATION ENDPOINT - Calculate property valuation from market stats\n// POST /webhook/valuation\n// Body: { district, ward, type, segment, area_m2, frontage_m, floors }\n// CRITICAL: Filter by market_segment (street_retail/office/shopping_mall)\n// ====================================================================\n\nconst body = $input.first().json.body || {};\n\nconst district = body.district || '';\nconst ward = body.ward || '';\nconst type = body.type || 'streetfront';\nconst segment = body.segment || body.market_segment || 'street_retail';  // CRITICAL!\nconst area = parseFloat(body.area_m2 || body.area) || 50;\nconst frontage = parseFloat(body.frontage_m || body.frontage) || 5;\nconst floors = parseInt(body.floors) || 1;\nconst province = body.province || body.city || '';\n\nlet listings = $getWorkflowStaticData('global').listings || [];\n\n// Reload if needed\nif (listings.length === 0) {\n  const fs = require('fs');\n  const paths = [\n    '/data/files/vn_rental_3cities_verified.json',\n    '/home/node/.n8n/files/vn_rental_3cities_verified.json'\n  ];\n  for (const p of paths) {\n    try {\n      if (fs.existsSync(p)) {\n        listings = JSON.parse(fs.readFileSync(p, 'utf8'));\n        $getWorkflowStaticData('global').listings = listings;\n        break;\n      }\n    } catch(e) {}\n  }\n}\n\nfunction normalize(str) {\n  if (!str) return '';\n  return str.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').trim();\n}\n\n// Filter comparable listings - CRITICAL: Use market_segment!\nlet comparables = listings.filter(l => {\n  // Segment MUST match (office vs retail vs mall) - THIS IS KEY!\n  if (segment && l.market_segment !== segment) return false;\n  \n  // Type should match\n  if (type && l.type !== type) return false;\n  \n  // District filter\n  if (district && !normalize(l.district || '').includes(normalize(district))) return false;\n  \n  // Ward filter (optional, more specific)\n  if (ward && !normalize(l.ward || '').includes(normalize(ward))) return false;\n  \n  // Province filter\n  if (province && !normalize(l.province || '').includes(normalize(province))) return false;\n  \n  return true;\n});\n\n// If ward filter too restrictive, fallback to district only\nif (comparables.length < 5 && ward) {\n  comparables = listings.filter(l => {\n    if (segment && l.market_segment !== segment) return false;  // Keep segment filter!\n    if (type && l.type !== type) return false;\n    if (district && !normalize(l.district || '').includes(normalize(district))) return false;\n    return true;\n  });\n}\n\n// Calculate rent per sqm for comparables\nconst rentPerSqm = comparables\n  .map(l => l.rent_per_sqm_million || ((l.price || l.price_million || 0) / (l.area || l.area_m2 || 1)))\n  .filter(r => r > 0 && r < 100) // Filter outliers\n  .sort((a, b) => a - b);\n\nconst n = rentPerSqm.length;\n\nlet p25 = 0.5, median = 1.0, p75 = 2.0;\n\nif (n > 0) {\n  p25 = rentPerSqm[Math.floor(n * 0.25)];\n  median = rentPerSqm[Math.floor(n * 0.5)];\n  p75 = rentPerSqm[Math.floor(n * 0.75)];\n}\n\n// Adjustment factor based on property characteristics\nlet adjustmentFactor = 1.0;\nlet adjustmentReasons = [];\n\nif (frontage > 8) {\n  adjustmentFactor += 0.15;\n  adjustmentReasons.push('Large frontage (+15%)');\n} else if (frontage > 5) {\n  adjustmentFactor += 0.05;\n  adjustmentReasons.push('Good frontage (+5%)');\n} else if (frontage < 3) {\n  adjustmentFactor -= 0.1;\n  adjustmentReasons.push('Narrow frontage (-10%)');\n}\n\nif ((type === 'shophouse' || type === 'office') && floors > 2) {\n  const floorBonus = (floors - 2) * 0.03;\n  adjustmentFactor += floorBonus;\n  adjustmentReasons.push(`Multi-floor (${floors} floors, +${Math.round(floorBonus * 100)}%)`);\n}\n\n// Area adjustment\nif (area > 150) {\n  adjustmentFactor -= 0.05;\n  adjustmentReasons.push('Large area discount (-5%)');\n} else if (area < 30) {\n  adjustmentFactor += 0.1;\n  adjustmentReasons.push('Small area premium (+10%)');\n}\n\n// Calculate suggested prices\nconst suggestedPricePerSqm = median * adjustmentFactor;\nconst minPricePerSqm = p25 * adjustmentFactor * 0.95;\nconst maxPricePerSqm = p75 * adjustmentFactor * 1.05;\n\nconst suggestedPrice = suggestedPricePerSqm * area;\nconst minPrice = minPricePerSqm * area;\nconst maxPrice = maxPricePerSqm * area;\n\n// Confidence based on sample size\nlet confidence = 'low';\nif (n >= 30) confidence = 'high';\nelse if (n >= 10) confidence = 'medium';\n\n// Risk level based on confidence and price variance\nconst priceVariance = p75 > 0 ? ((p75 - p25) / median) : 1;\nlet riskLevel = 'low';\nif (confidence === 'low' || priceVariance > 1) riskLevel = 'high';\nelse if (confidence === 'medium' || priceVariance > 0.5) riskLevel = 'medium';\n\n// Potential score (mock: based on area characteristics)\nconst potentialScore = Math.min(100, Math.max(0,\n  50 + (frontage > 5 ? 15 : 0) + (n >= 20 ? 10 : 0) + (floors > 1 ? 10 : 0) + (area > 50 ? 10 : 0)\n));\n\nreturn {\n  json: {\n    success: true,\n    input: {\n      district,\n      ward,\n      type,\n      area_m2: area,\n      frontage_m: frontage,\n      floors,\n      province\n    },\n    market_stats: {\n      p25_per_sqm: Math.round(p25 * 1000) / 1000,\n      median_per_sqm: Math.round(median * 1000) / 1000,\n      p75_per_sqm: Math.round(p75 * 1000) / 1000,\n      sample_size: n,\n      comparable_listings: comparables.slice(0, 5).map(l => ({\n        id: l.id,\n        name: l.name,\n        price: l.price || l.price_million,\n        area: l.area || l.area_m2,\n        rent_per_sqm: l.rent_per_sqm_million\n      }))\n    },\n    valuation: {\n      suggested_price_million: Math.round(suggestedPrice * 10) / 10,\n      price_range: {\n        min: Math.round(minPrice * 10) / 10,\n        max: Math.round(maxPrice * 10) / 10\n      },\n      priceRange: {\n        min: Math.round(minPrice * 10) / 10,\n        max: Math.round(maxPrice * 10) / 10\n      },\n      price_per_sqm: Math.round(suggestedPricePerSqm * 1000) / 1000,\n      adjustment_applied: Math.round((adjustmentFactor - 1) * 100) + '%',\n      adjustment_reasons: adjustmentReasons,\n      confidence,\n      riskLevel,\n      potentialScore\n    }\n  }\n};"
      },
      "id": "valuation-calc",
      "name": "Calculate Valuation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 1040]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "valuation-respond",
      "name": "Valuation Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 1040]
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// DISTRICTS ENDPOINT - Get list of districts by province\n// GET /webhook/districts?city=\n// ====================================================================\n\nconst query = $input.first().json.query || {};\nconst cityFilter = query.city || query.province || '';\n\nlet listings = $getWorkflowStaticData('global').listings || [];\n\n// Reload if needed\nif (listings.length === 0) {\n  const fs = require('fs');\n  const paths = [\n    '/data/files/vn_rental_3cities_verified.json',\n    '/home/node/.n8n/files/vn_rental_3cities_verified.json'\n  ];\n  for (const p of paths) {\n    try {\n      if (fs.existsSync(p)) {\n        listings = JSON.parse(fs.readFileSync(p, 'utf8'));\n        $getWorkflowStaticData('global').listings = listings;\n        break;\n      }\n    } catch(e) {}\n  }\n}\n\nfunction normalize(str) {\n  if (!str) return '';\n  return str.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').trim();\n}\n\n// Get unique districts grouped by province\nconst provinces = {};\n\nlistings.forEach(l => {\n  const prov = l.province || 'Unknown';\n  const dist = l.district || 'Unknown';\n  \n  // Filter by city if specified\n  if (cityFilter && !normalize(prov).includes(normalize(cityFilter))) {\n    return;\n  }\n  \n  if (!provinces[prov]) {\n    provinces[prov] = new Set();\n  }\n  provinces[prov].add(dist);\n});\n\n// Convert to array format\nconst result = Object.entries(provinces).map(([province, districts]) => ({\n  province,\n  districts: Array.from(districts).sort()\n}));\n\nreturn {\n  json: {\n    success: true,\n    data: result,\n    count: result.reduce((sum, p) => sum + p.districts.length, 0)\n  }\n};"
      },
      "id": "districts-compute",
      "name": "Get Districts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 1240]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "districts-respond",
      "name": "Districts Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 1240]
    }
  ],
  "connections": {
    "Search Webhook": {
      "main": [[{ "node": "Search Filter", "type": "main", "index": 0 }]]
    },
    "Search Filter": {
      "main": [[{ "node": "Search Response", "type": "main", "index": 0 }]]
    },
    "Listing Webhook": {
      "main": [[{ "node": "Get Listing Detail", "type": "main", "index": 0 }]]
    },
    "Get Listing Detail": {
      "main": [[{ "node": "Listing Response", "type": "main", "index": 0 }]]
    },
    "Stats Webhook": {
      "main": [[{ "node": "Compute Stats", "type": "main", "index": 0 }]]
    },
    "Compute Stats": {
      "main": [[{ "node": "Stats Response", "type": "main", "index": 0 }]]
    },
    "ROI Webhook": {
      "main": [[{ "node": "Calculate ROI", "type": "main", "index": 0 }]]
    },
    "Calculate ROI": {
      "main": [[{ "node": "ROI Response", "type": "main", "index": 0 }]]
    },
    "Valuation Webhook": {
      "main": [[{ "node": "Calculate Valuation", "type": "main", "index": 0 }]]
    },
    "Calculate Valuation": {
      "main": [[{ "node": "Valuation Response", "type": "main", "index": 0 }]]
    },
    "Districts Webhook": {
      "main": [[{ "node": "Get Districts", "type": "main", "index": 0 }]]
    },
    "Get Districts": {
      "main": [[{ "node": "Districts Response", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "meta": {
    "description": "JFinder API - All endpoints using JSON file (no Postgres). Reads from verified 3-cities dataset."
  }
}
