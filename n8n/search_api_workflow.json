{
  "name": "API - Search Listings (Fixed SQL)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "search",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-1",
      "name": "Search Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        320
      ],
      "webhookId": "search-listings"
    },
    {
      "parameters": {
        "jsCode": "// Build dynamic query - FIXED: Direct string interpolation instead of parameters\nconst query = $input.first().json.query || {};\n\nlet whereClauses = ['1=1'];\n\n// City filter (escape single quotes for SQL)\nif (query.city || query.province) {\n  const city = (query.city || query.province).replace(/'/g, \"''\");\n  whereClauses.push(`province ILIKE '%${city}%'`);\n}\n\n// District filter\nif (query.district) {\n  const district = query.district.replace(/'/g, \"''\");\n  whereClauses.push(`district ILIKE '%${district}%'`);\n}\n\n// Ward filter\nif (query.ward) {\n  const ward = query.ward.replace(/'/g, \"''\");\n  whereClauses.push(`ward ILIKE '%${ward}%'`);\n}\n\n// Type filter\nif (query.type) {\n  const type = query.type.replace(/'/g, \"''\");\n  whereClauses.push(`type = '${type}'`);\n}\n\n// Segment filter\nif (query.segment) {\n  const segment = query.segment.replace(/'/g, \"''\");\n  whereClauses.push(`market_segment = '${segment}'`);\n}\n\n// Price filters\nif (query.min_price || query.minPrice) {\n  const minP = parseFloat(query.min_price || query.minPrice);\n  whereClauses.push(`price_million >= ${minP}`);\n}\nif (query.max_price || query.maxPrice) {\n  const maxP = parseFloat(query.max_price || query.maxPrice);\n  whereClauses.push(`price_million <= ${maxP}`);\n}\n\n// Area filters\nif (query.min_area || query.minArea) {\n  const minA = parseFloat(query.min_area || query.minArea);\n  whereClauses.push(`area_m2 >= ${minA}`);\n}\nif (query.max_area || query.maxArea) {\n  const maxA = parseFloat(query.max_area || query.maxArea);\n  whereClauses.push(`area_m2 <= ${maxA}`);\n}\n\n// Radius search via Haversine\nlet radiusFilter = '';\nif (query.lat && query.lon && query.radius_m) {\n  const lat = parseFloat(query.lat);\n  const lon = parseFloat(query.lon);\n  const radiusKm = parseFloat(query.radius_m) / 1000;\n  \n  radiusFilter = `\n    AND (\n      6371 * acos(\n        cos(radians(${lat})) * cos(radians(latitude)) *\n        cos(radians(longitude) - radians(${lon})) +\n        sin(radians(${lat})) * sin(radians(latitude))\n      )\n    ) <= ${radiusKm}`;\n}\n\n// Pagination\nconst limit = parseInt(query.limit) || 50;\nconst offset = parseInt(query.offset) || 0;\n\n// Build final SQL - Direct string interpolation\nconst sql = `\nSELECT \n  id, name, address, province, district, ward,\n  latitude, longitude, type, market_segment,\n  area_m2, frontage_m, floors,\n  price_million, rent_per_sqm_million,\n  views, saved_count,\n  primary_image_url,\n  ai_suggested_price, ai_potential_score, ai_risk_level,\n  posted_at,\n  created_at\nFROM listings\nWHERE ${whereClauses.join(' AND ')}${radiusFilter}\nORDER BY created_at DESC NULLS LAST\nLIMIT ${limit} OFFSET ${offset}\n`;\n\nreturn {\n  json: {\n    sql: sql,\n    limit: limit,\n    offset: offset\n  }\n};"
      },
      "id": "code-build",
      "name": "Build Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        320
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {}
      },
      "id": "postgres-data",
      "name": "Query Data",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        680,
        320
      ],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "JFinder DB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Add price label based on ai_suggested_price\nconst listings = $input.all();\nconst output = [];\n\nfor (const item of listings) {\n  const data = item.json;\n  \n  // Calculate price label\n  let priceLabel = 'fair';\n  if (data.ai_suggested_price && data.price_million) {\n    const ratio = data.price_million / data.ai_suggested_price;\n    if (ratio < 0.9) priceLabel = 'cheap';\n    else if (ratio > 1.1) priceLabel = 'expensive';\n  }\n  \n  output.push({\n    json: {\n      ...data,\n      price_label: priceLabel\n    }\n  });\n}\n\nreturn output;"
      },
      "id": "code-label",
      "name": "Add Price Labels",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        320
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, data: $input.all().map(i => i.json), count: $input.all().length } }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-1",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1120,
        320
      ]
    }
  ],
  "connections": {
    "Search Webhook": {
      "main": [
        [
          {
            "node": "Build Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Query": {
      "main": [
        [
          {
            "node": "Query Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Data": {
      "main": [
        [
          {
            "node": "Add Price Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Price Labels": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
